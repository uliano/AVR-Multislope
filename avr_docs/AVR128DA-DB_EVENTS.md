# Event System (EVSYS) - AVR128DA/DB Reference

## Hardware Overview

The **Event System** is a hardware routing system that connects event generators to event users without software overhead.

**AVR128DA/DB** provides:
- **10 event channels** (CHANNEL0-CHANNEL9)
- **Two subchannels per channel**: asynchronous + synchronous
- **Zero CPU latency** (completely hardware-based)
- **Events from**: Timers, CCL, ADC, AC, USART, SPI, GPIO, etc.
- **Events to**: CCL, TCB, ADC, AC, USART, TCD, EVOUT, etc.
- **Software events** via EVSYS.SWEVENTA/B

## System Architecture

```
┌─────────────┐         ┌──────────┐         ┌─────────────┐
│  Generator  │────────>│ CHANNEL0 │────────>│    User     │
│  (TCA0 OVF) │         │  (0x80)  │         │ (CCL LUT2A) │
└─────────────┘         └──────────┘         └─────────────┘
                             │
                             └──────────────> Other Users
```

### Channels

Each channel can be configured with one **generator**:

```c
EVSYS.CHANNEL0 = EVSYS_CHANNEL0_TCA0_OVF_gc;  // TCA0 overflow → CH0
```

### Users

Each user can be connected to one channel:

```c
EVSYS.USERCCLLUT2A = USERVAL(0);  // CH0 → LUT2 EVENTA input
```

**Helper macro** for user value:
```c
#define USERVAL(ch) ((uint8_t)((ch) + 1u))
// User value = channel number + 1
// Channel 0 → User value = 1
// Channel 5 → User value = 6
```

## Synchronization and Event Types (datasheet)

Events can be synchronous or asynchronous to the peripheral clock (CLK_PER). Each event channel has two subchannels:

- **Asynchronous subchannel**: identical to the generator output.
- **Synchronous subchannel**: identical for synchronous generators; asynchronous sources are synchronized before routing.

Additional constraints:
- A synchronous user listens to the synchronous subchannel; an asynchronous user listens to the asynchronous subchannel.
- An asynchronous event used by a synchronous consumer must last at least one CLK_PER cycle to propagate.
- Synchronization adds a 2-3 cycle delay on the synchronous subchannel when the generator is asynchronous.

## Software Events (SWEVENTx) (datasheet)

Software events are generated by writing '1' to EVSYS.SWEVENTx bits:

```c
// Channel 0 software event (single pulse)
EVSYS.SWEVENTA = (1 << 0);
```

- Writing a bit to '1' generates a single-pulse event by inverting the channel signal for one peripheral clock cycle.
- Event users see software events the same as events from peripherals.
- SWEVENTA bits 0-7 map to channels 0-7; SWEVENTB bits 0-7 map to channels 8-15 (on AVR128DA/DB, channels 8-9 are used).

## Sleep Mode Operation (datasheet)

- When configured, the Event System works in all sleep modes; software events require the peripheral clock.
- Asynchronous event users can respond without their clock running in Standby.
- Synchronous event users need their clock running; they work in Idle or in Standby when RUNSTDBY is set for the peripheral.
- Asynchronous event generators can generate events without their clock running in Standby; synchronous generators need their clock running and therefore require Idle or Standby with RUNSTDBY set.

## Event Generators

### Timer/Counter Generators

| Generator | Value | Description |
|-----------|-------|-------------|
| `TCA0_OVF` | 0x80 | TCA0 overflow (TOP reached) |
| `TCA0_HUNF` | 0x81 | TCA0 HUNF (high underflow, split mode) |
| `TCA0_CMP0` | 0x84 | TCA0 compare match 0 |
| `TCA0_CMP1` | 0x85 | TCA0 compare match 1 |
| `TCA0_CMP2` | 0x86 | TCA0 compare match 2 |
| `TCA1_OVF` | 0x88 | TCA1 overflow |
| `TCA1_HUNF` | 0x89 | TCA1 HUNF |
| `TCA1_CMP0` | 0x8C | TCA1 compare match 0 |
| `TCA1_CMP1` | 0x8D | TCA1 compare match 1 |
| `TCA1_CMP2` | 0x8E | TCA1 compare match 2 |
| `TCB0_CAPT` | 0xA0 | TCB0 capture event |
| `TCB0_OVF` | 0xA1 | TCB0 overflow |
| `TCB1_CAPT` | 0xA2 | TCB1 capture event |
| `TCB1_OVF` | 0xA3 | TCB1 overflow |
| `TCB2_CAPT` | 0xA4 | TCB2 capture event |
| `TCB2_OVF` | 0xA5 | TCB2 overflow |
| `TCB3_CAPT` | 0xA6 | TCB3 capture event |
| `TCB3_OVF` | 0xA7 | TCB3 overflow |

### CCL Generators

| Generator | Value | Description |
|-----------|-------|-------------|
| `CCL_LUT0` | 0x10 | LUT0 output |
| `CCL_LUT1` | 0x11 | LUT1 output |
| `CCL_LUT2` | 0x12 | LUT2 output |
| `CCL_LUT3` | 0x13 | LUT3 output |
| `CCL_LUT4` | 0x14 | LUT4 output |
| `CCL_LUT5` | 0x15 | LUT5 output |

**Note**: Exact values depend on the channel - always use the constants `EVSYS_CHANNELx_CCL_LUTn_gc`.

### GPIO Generators

| Port | Pin | Value | Description |
|------|-----|-------|-------------|
| PORTA | PIN0 | 0x40 | PA0 pin event |
| PORTA | PIN1 | 0x41 | PA1 pin event |
| ... | ... | ... | ... |
| PORTD | PIN0 | 0x4C | PD0 pin event |
| PORTE | PIN0 | 0x58 | PE0 pin event |
| PORTE | PIN1 | 0x59 | PE1 pin event |
| ... | ... | ... | ... |
| PORTF | PIN0 | 0x64 | PF0 pin event |

**IMPORTANT**: GPIO events are **edge-triggered** (edge), not level-triggered (level)!

### Other Generators

- **ADC0**: `ADC0_RESRDY` (conversion ready)
- **AC0**: `AC0_OUT` (comparator output)
- **USART**: `USARTn_XCK` (USART clock)
- **SPI0**: `SPI0_SCK` (SPI clock)

## Event Users

### CCL Users

Each LUT has 2 event inputs (EVENTA and EVENTB):

```c
EVSYS.USERCCLLUT0A = USERVAL(ch);  // Channel → LUT0 EVENTA
EVSYS.USERCCLLUT0B = USERVAL(ch);  // Channel → LUT0 EVENTB
EVSYS.USERCCLLUT1A = USERVAL(ch);  // Channel → LUT1 EVENTA
EVSYS.USERCCLLUT1B = USERVAL(ch);  // Channel → LUT1 EVENTB
// ... up to LUT5A/LUT5B
```

**Mapping to LUT inputs**:
- `EVENTA` → Can be used for **IN2** (clock for sequencer DFF)
- `EVENTB` → Can be used for **IN0, IN1, IN2** (configurable)

### TCB Users (Event Counting)

```c
EVSYS.USERTCB0COUNT = USERVAL(ch);  // TCB0 counts events from channel
EVSYS.USERTCB1COUNT = USERVAL(ch);  // TCB1 counts events from channel
EVSYS.USERTCB2COUNT = USERVAL(ch);  // TCB2 counts events from channel
EVSYS.USERTCB3COUNT = USERVAL(ch);  // TCB3 counts events from channel
```

**TCB configuration for event counting**:
```c
TCBn.CTRLA = TCB_CLKSEL_EVENT_gc;  // Clock source = event
TCBn.CTRLB = TCB_CNTMODE_INT_gc;   // Interrupt mode
TCBn.EVCTRL = TCB_CAPTEI_bm;       // Enable event input
TCBn.CTRLA |= TCB_ENABLE_bm;       // Enable
```

### Other Users

- **ADC0**: Trigger ADC conversion
- **TCD0**: Clock or input for TCD
- **EVOUT**: Physical output of events on GPIO pins

## Typical Configuration

```c
// 1. Configure generator → channel
EVSYS.CHANNEL0 = EVSYS_CHANNEL0_TCA0_OVF_gc;

// 2. Connect channel → user
EVSYS.USERCCLLUT2A = USERVAL(0);  // CH0 → LUT2 EVENTA

// 3. Configure LUT to use EVENTA as input
CCL.LUT2CTRLC = CCL_INSEL2_EVENTA_gc;
```

## Known Errata and Limitations (AVR128DA/DB)

### 1. GPIO Events are Edge-Triggered ⚠️ CRITICAL

**Issue**: Events from GPIO pins (PORTE PIN0, etc.) generate events only on **edges** (rising/falling edge), NOT on static levels.

**Impact**: If using GPIO for static control signals (like ENABLE), the event is generated only when the signal changes, not continuously.

**Example failure**:
```c
// PE0 as static enable for CCL
EVSYS.CHANNEL4 = 0x58;  // PORTE PIN0
EVSYS.USERCCLLUT0A = USERVAL(4);  // ENABLE → LUT0

// ❌ PROBLEM: When PE0=1 static, event is generated ONCE
// LUTs see event as pulse, not continuous level!
```

**Solutions**:

#### Option A: Use LUT as buffer (continuous level)
```c
// Intermediate LUT to convert GPIO edge → continuous level
CCL.LUT5CTRLB = CCL_INSEL0_IO_gc;  // GPIO direct (not event)
CCL.LUT5TRUTH = 0xAA;  // Buffer IN0 → OUT
CCL.LUT5CTRLA = CCL_ENABLE_bm;

// LUT5 output generates continuous events
EVSYS.CHANNEL4 = EVSYS_CHANNEL4_CCL_LUT5_gc;
EVSYS.USERCCLLUT0A = USERVAL(4);
```

#### Option B: Use TCA PWM (0% or 100% duty)
```c
// TCA generates continuous OVF events with simulated level
TCA1.SINGLE.PER = 1;
TCA1.SINGLE.CMP0 = 0;    // 0% duty = continuous LOW
// or
TCA1.SINGLE.CMP0 = 1;    // 100% duty = continuous HIGH

EVSYS.CHANNEL4 = EVSYS_CHANNEL4_TCA1_OVF_gc;
```

#### Option C: External physical loop-back
```c
// Output on pin, read back from another pin as direct CCL input
PORTE.DIRSET = PIN0_bm;  // PE0 = output
CCL.LUT0CTRLC = CCL_INSEL2_IO_gc;  // Read PE0 as IO (not event)
```

### 2. Event Propagation Delay

**Issue**: Asynchronous sources routed to the synchronous subchannel are synchronized, adding a 2-3 CLK_PER cycle delay; asynchronous events must last at least one CLK_PER cycle to propagate.

**Impact**: Timing between an asynchronous generator and a synchronous user is delayed; immediate use of the event can be off by a few cycles.

**Workaround**: Use phase-shifted clock for dependent operations:
```c
// TCA0 generates event
// TCA1 is phase-shifted by 8 cycles -> counts AFTER event is propagated
TCA1.SINGLE.CNT = 8;  // Phase shift
```

### 3. Channel Conflicts

**Issue**: A channel can have ONE generator, but MULTIPLE users.

**Correct example**:
```c
EVSYS.CHANNEL5 = EVSYS_CHANNEL5_CCL_LUT2_gc;  // Q state
EVSYS.USERCCLLUT0B = USERVAL(5);  // User 1
EVSYS.USERCCLLUT1B = USERVAL(5);  // User 2 (OK, same channel)
EVSYS.USERCCLLUT4B = USERVAL(5);  // User 3 (OK)
```

**Incorrect example**:
```c
EVSYS.CHANNEL5 = EVSYS_CHANNEL5_CCL_LUT2_gc;
EVSYS.CHANNEL5 = EVSYS_CHANNEL5_TCA0_OVF_gc;  // ❌ Overwrites previous!
```

### 4. User Value = Channel + 1

**Issue**: Common error forgetting the +1 offset.

**Correct**:
```c
#define USERVAL(ch) ((uint8_t)((ch) + 1u))
EVSYS.USERCCLLUT0A = USERVAL(0);  // Channel 0 → user value 1
```

**Incorrect**:
```c
EVSYS.USERCCLLUT0A = 0;  // ❌ 0 = no channel, not channel 0!
```

### 5. Port Pins Not Connected to Event System (128DA)

**Issue**: On AVR128DA, pins **PB[7:6]** and **PE[7:4]** are not connected to the Event System (as input or output).

**Impact**: Cannot use events from PE4, PE5, PE6, PE7 or route events to these pins.

**Workaround**: Use other available pins.

**Note**: This erratum is specific to 128DA. Not documented for 128DB (presumably fixed).

### 6. Event Input vs Direct Input

Some peripherals can use **direct** inputs (without event system):

**Advantages of direct inputs**:
- Zero latency (no synchronization)
- Continuous levels (not edge-triggered)

**CCL example**:
```c
// Direct input (IO pin)
CCL.LUT0CTRLC = CCL_INSEL2_IO_gc;  // Reads GPIO level directly

// Input via event
CCL.LUT0CTRLC = CCL_INSEL2_EVENTA_gc;  // Reads from event system
EVSYS.USERCCLLUT0A = USERVAL(ch);
```

**When to use events**:
- Flexible routing from various sources
- Automatic pulse generation
- Synchronization with clock
- Event counting

**When to use direct inputs**:
- Static signals (levels)
- Critical zero latency
- GPIO pins close to peripheral

## Best Practices

### 1. Plan Channels in Advance

Create a channel map before starting:
```c
// events.h
#define CH_TICK        0
#define CH_OVERFLOW    1
#define CH_PULSE       2
// etc.
```

### 2. Document Routing

Add clear comments:
```c
EVSYS.CHANNEL5 = EVGEN_Q;  // LUT2 Q output → CH5 → LUT0/1/4/5 inputs
```

### 3. Verify User Values

Always use `USERVAL(ch)` macro:
```c
#define USERVAL(ch) ((uint8_t)((ch) + 1u))
```

### 4. Handle GPIO Edge-Triggered

For static signals, DO NOT use direct GPIO events - use LUT buffer or TCA PWM.

### 5. Consider Latency

For time-critical operations dependent on events, add phase shift:
```c
TCA1.SINGLE.CNT = 8;  // 8-cycle delay
```

### 6. Test with Logic Analyzer

Use physical pins for debug:
```c
EVSYS.USEREVSYSEVOUTA = USERVAL(ch);  // Event → PA2 (EVOUTA)
EVSYS.USEREVSYSEVOUTB = USERVAL(ch);  // Event → PA7 (EVOUTB)
```

## Debugging

### Verify Generator Configuration

```c
// Read channel configuration
uint8_t gen = EVSYS.CHANNEL0;
serial.print("CH0 generator: 0x");
serial.print(gen, 16);
```

### Verify User Configuration

```c
// Read connected user
uint8_t user = EVSYS.USERCCLLUT2A;
serial.print("LUT2A user channel: ");
serial.print(user - 1, 10);  // user-1 = channel number
```

### Use EVOUT to Visualize Events

```c
// Output events on physical pin
PORTA.DIRSET = PIN2_bm;  // PA2 = EVOUTA output
EVSYS.USEREVSYSEVOUTA = USERVAL(5);  // CH5 → PA2
// Now you can see CH5 events with oscilloscope on PA2
```

### Software Tools

```c
// Count events with TCB in debug mode
TCB0.CTRLA = TCB_CLKSEL_EVENT_gc | TCB_ENABLE_bm;
TCB0.EVCTRL = TCB_CAPTEI_bm;
// Read TCB0.CNT for number of events received
```

## Differences: 128DA vs 128DB

| Feature | AVR128DA | AVR128DB |
|---------|----------|----------|
| **GPIO Edge-Triggered** | ✅ Documented | ✅ Documented (identical) |
| **Pin PB[7:6]/PE[7:4]** | ❌ Not connected to EVSYS | ✅ Presumably OK (not in errata) |
| **Number of Channels** | 10 channels | 10 channels (identical) |
| **Event Generators** | Identical | Identical |
| **Event Users** | Identical | Identical |

## References

- **AVR128DA Datasheet**: Chapter 14 "Event System (EVSYS)"
- **AVR128DB Datasheet**: Chapter 14 "Event System (EVSYS)"
- **AVR128DA Errata Sheet**: DS80000882B (Rev. B, 11/2020)
- **AVR128DB Errata Sheet**: DS80000915A (Rev. A, 08/2020)
- **Application Note AN2451**: "Getting Started with Event System"

## Final Notes

The event system is a **powerful tool** for hardware-synchronized operations with zero CPU overhead. The key is:

1. **Plan** routing in advance
2. **Document** connections clearly
3. **Handle** limitations (GPIO edge-triggered, latency)
4. **Test** with hardware tools (logic analyzer)

With proper configuration, the event system enables complex operations (synchronous DFFs, conditional counting, ADC triggering) completely in hardware, freeing the CPU for other tasks!
